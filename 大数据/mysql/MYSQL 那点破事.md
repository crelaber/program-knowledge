## 目录

![图片](https://mmbiz.qpic.cn/mmbiz_png/2KTof9YshwerU9KoqeOEAry59z0QHvGu2xicL4gnibHbhQkmh9Vhyx8Xa6PhqG3It2zLgsGLtCkl9F7ianL9IXqbQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)



接下来，我们逐条来看看每个问题及答案

## **MyISAM 和 InnoDB 的区别？**

答案：InnoDB 支持 事务、外键、聚集索引，通过MVCC来支持高并发，索引和数据存储在一起。InnoDB 不保存表的具体行数，执行 `select count(*) from table` 时需要全表扫描。而MyISAM 用一个变量保存了整个表的行数。

InnoDB 最小的锁粒度是行锁，MyISAM 最小的锁粒度是表锁，并发能力低。MySQL 将默认存储引擎是 InnoDB

## **mysql 锁有哪些类型？**

答案：mysql锁分为共享锁( S lock ) 、排他锁 ( X lock )，也叫做读锁和写锁。根据粒度，可以分为表锁、页锁、行锁。

## **什么是间隙锁？**

答案：间隙锁是可重复读级别下才会有的锁，mysql会帮我们生成了若干`左开右闭`的区间，结合MVCC和间隙锁可以解决幻读问题。

## **如何避免死锁？**

答案：死锁的四个必要条件：1、互斥 2、请求与保持 3、环路等待 4、不可剥夺。

- 合理的设计索引，区分度高的列放到组合索引前面，使业务 SQL 尽可能通过索引定位更少的行，减少锁竞争。
- 调整业务逻辑 SQL 执行顺序， 避免 update/delete 长时间持有锁的 SQL 在事务前面。
- 避免大事务，将大事务拆成多个小事务
- 以固定的顺序访问表和行。比如两个更新数据的事务，事务 A 更新数据的顺序为 1，2;事务 B 更新数据的顺序为 2，1。这样更可能会造成死锁。
- 在并发比较高的系统中，不要显式加锁，特别是是在事务里显式加锁。如 select … for update 语句，如果是在事务里（运行了 start transaction 或设置了autocommit 等于0）,那么就会锁定所查找到的记录。
- 尽量用主键/索引去查找记录
- 优化 SQL 和表设计，减少同时占用太多资源的情况。比如说，避免多个表join，将复杂 SQL 分解为多个简单的 SQL。

## **数据库的隔离级别？**

答案：读未提交、读已提交、可重复读（mysql的默认级别，每次读取结果都一样，但是有可能产生幻读）、串行化。

## **Mysql有哪些类型的索引？**

答案：

- 普通索引：一个索引只包含一个列，一个表可以有多个单列索引。
- 唯一索引：索引列的值必须唯一，但允许有空值
- 复合索引：多列值组成一个索引，专门用于组合搜索，其效率大于索引合并
- 聚簇索引：也称为主键索引，是一种数据存储方式。B+Tree结构，非叶子节点包含健值和指针，叶子节点包含索引列和行数据。一张表只能有一个聚簇索引。
- 非聚簇索引：不是聚簇索引，就是非聚簇索引。叶子节点只是存索引列和主键id。如果sql还要返回除了索引列的其他字段信息，需要回表，第一次索引一般是顺序IO，回表的操作属于随机IO。回表的次数越多，性能越差。此时我们推荐`覆盖索引`

## **什么是覆盖索引和回表？**

答案：

1、覆盖索引，指的是在一次查询中，一个索引包含所有需要查询的字段的值，可能是返回值或where条件

```
select buyer_id from order where money>100
```

假如我们创建了一个(money，buyer_id)的联合索引，索引的叶子节点包含了`buyer_id`的信息，则不会再`回表`查询。

2、回表，指查询时一些字段值拿不到，需要到主键索引B+树再查一次。

## **Mysql的最左前缀原则？**

答案：即最左优先，在检索数据时从联合索引的最左边开始匹配，直到遇到范围查询（如：> 、< 、between、like等）

例子：where a = 1 and b = 2 and c > 3 and d = 4 ，如果建立(a,b,c,d)组合索引，d是用不到索引的；如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。

## **线上SQL的调优经验？**

答案：

- 1、`slow_query_log` 日志中收集到的慢 SQL ，结合 `explain` 分析是否命中索引。
- 2、减少索引扫描行数，有针对性的优化慢 SQL。
- 3、建立联合索引，由于联合索引的每个叶子节点包含检索字段的信息，按最左前缀原则匹配后，再按其它条件过滤，减少回表的数据量。
- 4、还可以使用虚拟列和联合索引来提升复杂查询的执行效率。

## **官方为什么建议采用自增id 作为主键？**

答案：自增id是连续的，插入过程也是顺序的，总是插入在最后，减少了页分裂，有效减少数据的移动。所以尽量不要使用字符串（如：UUID）作为主键。

## **索引为什么采用B+树，而不用B-树，红黑树？**

答案：提升查询速度，首先要减少磁盘IO次数，也就是要降低树的高度。

- 平衡二叉树、红黑树，都属于二叉树。时间复杂度为O(n)，当表的数据量上千万时，树的深度很深，mysql读取时消耗大量 IO。另外，InnoDB引擎采用`页`为单位读取，每个节点一页，但是二叉树每个节点储存一个关键词，导致空间浪费。
- B-树，非叶子节点存储数据，占用较多空间，导致每个节点的`指针`少很多，无形增加了树的深度。
- B+树数据都存储在叶子节点，非叶子节点只存储`健值+指针`，索引树更加扁平，三层深度可以支持千万级表存储。同时叶子节点之间通过链表关联，范围查找更快。
- 更多内容，参考 [**mysql 一棵 B+ 树能存多少条数据？**](https://mp.weixin.qq.com/s?__biz=Mzg2NzYyNjQzNg==&mid=2247485030&idx=1&sn=fae128c2991e69101e6e4732001bcb76&scene=21#wechat_redirect)

## **事务的特性有哪些？**

答案：ACID。

- 原子性。一个事务中的操作要么全部成功，要么全部失败。
- 持久性。永久保存在数据库中。
- 一致性。总是从一个一致性的状态转换到另一个一致性的状态
- 隔离性。一个事务的修改在提交前，其他事务是感知不到的

## **如何实现分布式事务？**

答案：

- 1、流水任务，最终一致性，前提是接口要支持幂等性
- 2、事务消息
- 3、二阶段提交
- 4、三阶段提交
- 5、TCC
- 6、Seata 框架
- 7、更多内容，参考 [**如何解决分布式事务**](https://mp.weixin.qq.com/s?__biz=Mzg2NzYyNjQzNg==&mid=2247484829&idx=1&sn=60f39021b58762ea909ea5ae53434945&scene=21#wechat_redirect)

## **日常工作中，MySQL 如何做优化？**

答案：

- 1、分页优化。比如电梯直达，`limit 100000,10` 先查找起始的主键id，再通过`id>#{value}`往后取10条
- 2、尽量使用`覆盖索引`，索引的叶节点中已经包含要查询的字段，减少`回表查询`
- 3、SQL优化（索引优化、小表驱动大表、虚拟列、适当增加冗余字段减少连表查询、联合索引、排序优化、慢日志 Explain 分析执行计划）。
- 4、设计优化（避免使用NULL、用简单数据类型如int、减少 text 类型、分库分表）。
- 5、硬件优化（使用SSD 减少 I/O 时间、足够大的网络带宽、尽量大的内存）

## **mysql 主从同步具体过程？**

答案：

- master主库，有数据更新，将此次更新的事件类型写入到主库的binlog文件中
- 主库会创建`log dump 线程`通知slave有数据更新
- slave，向master节点的 log dump线程请求一份指定binlog文件位置的副本，并将请求回来的`binlog`存到本地的`Relay log` 中继日志中
- slave 再开启一个`SQL 线程`读取`Relay log`事件，并在本地执行`redo`操作。将发生在主库的事件在本地重新执行一遍，从而保证主从数据同步

![图片](https://mmbiz.qpic.cn/mmbiz_png/2KTof9YshwerU9KoqeOEAry59z0QHvGuIAmxHAic1iaQ7iaLSDKrPpL79kIMlyzg85ZBJ80icXFianB6bpEEoqXCmkg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)



## **什么是主从延迟？**

答案：指一个写入SQL操作在主库执行完后，将数据完整同步到从库会有一个时间差，称之为主从延迟。计算公式：

- 主库生成一条写入SQL的binlog，里面会有一个时间字段，记录写入的时间戳 t1
- binlog 同步到从库后，一旦开始执行，取当前时间 t2
- `t2-t1`，就是延迟时间

注意：不同服务器要保持时钟一致

## **主从延迟排查方法？**

答案：通过 `show slave status` 命令输出的`Seconds_Behind_Master`参数的值来判断

![图片](https://mmbiz.qpic.cn/mmbiz_png/2KTof9YshwerU9KoqeOEAry59z0QHvGuexWFBt1UicXjUucmxBS3ygm6VIzfEehDiboKhatIia7JqReEVoeG2ibYlQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

- 为零：表示主从复制良好
- 正值：表示主从已经出现延时，数字越大，表示从库延迟越严重

## **主从延迟要怎么解决？**

答案：

- 看业务的接受程度。如果不能接受延迟，那么建议强制走主库查询
- 可以考虑引入缓存，更新主库后同步写入缓存，保证缓存的及时性
- 提升从库的机器配置，提高从库binlog的同步效率
- 缩短主、从库的网络距离，减少binlog的网络传输时间
- 一主多从，每个从库都启一个线程从主库同步 binlog，导致主库压力过大，可以采用`canal` 增量订阅&消费组件，缓解主库压力。
- 因为数据库必须要等到事务完成之后才会写入binlog，所以减少大事务的执行，尽量控制数量，分批执行。
- 5.6版本之前，从库是单线程复制，当遇到执行慢的sql时，就会阻塞后面的同步。5.7 版本后支持多线程复制，可以在从服务上设置`slave_parallel_workers`为一个大于0的数，然后把`slave_parallel_type`参数设置为`LOGICAL_CLOCK`
- 为从库增加浮动IP，并通过脚本检测从库的延迟，延迟大于指定阈值时，将浮动IP切换至Master库，追平后再切换回从库。

## **如果数据量太大怎么办？**

答案：mysql表的数据量一般控制在千万级别，如果再大的话，就要考虑分库分表。除了分表外，列举了面对海量数据业务的一些常见优化手段

- 缓存加速
- 读写分离
- 垂直拆分
- 分库分表
- 冷热数据分离
- ES助力复杂搜索
- NoSQL
- NewSQL
- 更多内容，参考 [**海量数据业务有哪些优化手段？**](https://mp.weixin.qq.com/s?__biz=Mzg2NzYyNjQzNg==&mid=2247484915&idx=1&sn=0e341fd27fe9edd2d957f637e3a955c4&scene=21#wechat_redirect)

## **分表后ID如何保证全局唯一呢？**

答案：分库分表后，多张表共用一套全局id，原来单表主键自增方式满足不了要求。我们需要重新设计一套id生成器。特点：全局唯一、高性能、高可用、方便接入。

- UUID
- 数据库自增ID
- 数据库的号段模式，每个业务定义起始值、步长，一次拉取多个id号码
- 基于Redis，通过`incr`命令实现ID的原子性自增。
- 雪花算法（Snowflake）
- 市面的一些开源框架，如：百度（uid-generator），美团（Leaf）， 滴滴（Tinyid）等

## **分表后可能遇到的哪些问题？**

答案：分表后，与单表的最大区别是有分表键`sharding_key`，用来路由具体的物理表，以电商为例，有买家和卖家两个维度，以`buyer_id`路由，无法满足卖家的需求，反之同样道理。如何解决？

- 分买家库和卖家库，将买家库做为写库，保存完整的数据关系。同时将数据异构同步一份到卖家库，卖家库可以只存储`seller_id，order_id，buyer_id` 等几个简单关系字段即可，以`seller_id`作为分表键
- 多线程扫描，分段查找，然后再聚合结果
- 另外也可以存到ES中，支持多维度复杂搜索